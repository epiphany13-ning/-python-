### 玩具蛇 1022
是否需要重刷：要
学到的知识点：dfs
1 标记数组
2 方向数组
3 什么时候需要回溯
4 这是递归的写法和bfs不同
相关代码：
def dfs(x,y,n):
    global ans
    if n == 16:
        ans += 1
        return
    for delta_x,delta_y in [(0,1),(0,-1),(1,0),(-1,0)]:
        xx,yy = delta_x + x,delta_y + y
        if 0 <= xx < 4 and 0 <= yy < 4 and vis[xx][yy] != 1:#没有走过才继续往下走
            vis[xx][yy] = 1
            dfs(xx,yy,n + 1)
            vis[xx][yy] = 0
vis = [[0] * 4 for i in range(4)]
ans = 0
for x in range(4):
    for y in range(4):
        vis[x][y] = 1
        dfs(x,y,1)#先打标记再走
        vis[x][y] = 0#记得消除标记
print(ans)
### 平均3532
是否需要重刷：要
需要注意点：
1读题 确保每个数字出现的次数相同
2如何对列表进行正确的排序方法

**这两段代码排序部分的区别**
第一部分：a[x].sort()
          并没有指明x的具体值，python只能默认是0那就指对第一个子列表进行排序而已
疑惑：为什么需要进行排序这一操作
答：因为题目并没有说明是不是按代价的价值排序顺序进行输入的
因此需要进行排序操作
1)
a[x].sort()  # 根据子列表的内容进行排序
for i in range(10):
    ans += sum(a[i][:-k]) 
2)
for i in range(10):
    a[i].sort()
    ans += sum(a[i][:-k])  # 计算总代价
print(ans)
3 如何存放对应数字出现的次数
细节：
1 利用数字和对应索引的值相同，进行次数加和即可

4 如何正确创建空的子列表
正确形式：
[[] for i in range(n)]
错例:
[[], [[]], [[[]]], ..., [[[[]] ... []]]但是这里表现出来的不是嵌套的意思吗

我理解您的疑问。在我之前的回答中，我的表述可能造成了一些混淆。让我们澄清这个问题。

当您看到像 `[[], [[]], [[[]]]]` 这样的输出时，这确实是一个嵌套列表的表示，但这并不是由 `a = [[]*i for i in range(10)]` 这行代码直接产生的。实际上，这行代码会产生一个列表，其中每个元素都是一个空列表。但是，当您尝试打印或查看这个列表时，Python 的字符串表示会为了可读性而将连续的空列表合并显示。

例如，`[[[]], [[]], [[]]]` 会被显示为 `[[], [[]], [[[]]]]`，因为连续的空列表在打印时会被合并。这种显示方式可能会让人误解为列表中有嵌套结构，但实际上，每个元素都是一个独立的空列表，它们只是被连续地打印出来了。

正确的理解是，`a = [[]*i for i in range(10)]` 会产生一个列表 `a`，其中包含10个元素，每个元素都是一个空列表。这些元素是并列的，没有嵌套关系。当您打印这个列表时，Python 的字符串表示可能会将连续的空列表合并显示，但这并不代表它们在内存中是嵌套的。

如果您想要创建一个列表，其中包含多个嵌套级别的空列表，您需要使用不同的方法来构建每个子列表。例如：

```python
a = [[i] * i for i in range(10)]
```

这行代码会产生一个列表 `a`，其中包含从0到9的数字，每个数字重复自身相应次数。这将导致一个列表，其中每个元素都是一个嵌套列表，嵌套的层数与元素的值相同。例如，`a[3]` 将会是 `[0, 1, 2]`，因为 `3` 重复了3次。


















