### 3519填充
是否需要重刷：要
学会的知识点：如何正确检查目标字符串是否出现在字符串中
遗忘知识点：
是的，`s[i-1:i+1]` 表示的是一个前闭后开的区间。在Python中，字符串切片操作 `s[start:end]` 会从索引 `start`（包含）开始，到索引 `end`（不包含）结束，获取子字符串。

在这个特定的例子中：

- `i-1` 是切片的起始索引，它是包含在内的。
- `i+1` 是切片的结束索引，但是切片操作不包含这个索引本身，而是取到这个索引之前的最后一个字符。

因此，`s[i-1:i+1]` 获取的是从 `i-1` 索引开始，到 `i` 索引结束（但不包括 `i`）的子字符串。这意味着它会包含 `i-1` 索引处的字符和 `i` 索引处的字符，但不会包含 `i+1` 索引处的字符。

例如，假设 `s = "0011001010"` 并且 `i = 4`，那么 `s[i-1:i+1]` 将会是 `s[3:5]`，结果将是子字符串 `"10"`。这里，索引 `3`（包含）和 `4`（包含）的字符都被包括在内，而索引 `5`（不包含）的字符则不在切片结果中。

大佬的代码：
n = input()
ans = 0
judge = ["00","11","?1","?0","0?","1?","??"]
i = 0
while i < len(n) - 1:
    if n[i:i+2] in judge:
        ans += 1
        i += 2
    else:
        i += 1
print(ans)
巧妙之处：
1 并没有对？进行修改操作，而是判断？与谁组合可以出现正确答案
2 贪心，目标字符串最多出现次数，一定是尽量确保每一次都出现。因此，一定是从头开始搜索
3 没有对字符串中的元素进行修改，而是利用下标和while关键字结合的方式对代码的效率进行优化操作。
