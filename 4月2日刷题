### 3519填充
是否需要重刷：要
学会的知识点：如何正确检查目标字符串是否出现在字符串中
遗忘知识点：
是的，`s[i-1:i+1]` 表示的是一个前闭后开的区间。在Python中，字符串切片操作 `s[start:end]` 会从索引 `start`（包含）开始，到索引 `end`（不包含）结束，获取子字符串。

在这个特定的例子中：

- `i-1` 是切片的起始索引，它是包含在内的。
- `i+1` 是切片的结束索引，但是切片操作不包含这个索引本身，而是取到这个索引之前的最后一个字符。

因此，`s[i-1:i+1]` 获取的是从 `i-1` 索引开始，到 `i` 索引结束（但不包括 `i`）的子字符串。这意味着它会包含 `i-1` 索引处的字符和 `i` 索引处的字符，但不会包含 `i+1` 索引处的字符。

例如，假设 `s = "0011001010"` 并且 `i = 4`，那么 `s[i-1:i+1]` 将会是 `s[3:5]`，结果将是子字符串 `"10"`。这里，索引 `3`（包含）和 `4`（包含）的字符都被包括在内，而索引 `5`（不包含）的字符则不在切片结果中。

大佬的代码：
n = input()
ans = 0
judge = ["00","11","?1","?0","0?","1?","??"]
i = 0
while i < len(n) - 1:
    if n[i:i+2] in judge:
        ans += 1
        i += 2
    else:
        i += 1
print(ans)
巧妙之处：
1 并没有对？进行修改操作，而是判断？与谁组合可以出现正确答案
2 贪心，目标字符串最多出现次数，一定是尽量确保每一次都出现。因此，一定是从头开始搜索
3 没有对字符串中的元素进行修改，而是利用下标和while关键字结合的方式对代码的效率进行优化操作。
### 3526 子树的大小
是否需要重刷：要
学会的知识点：如何快速定位左子节点以及右子节点
感觉这种思维题可遇不可求
T = int(input())
for i in range(T):
    n,m,k = map(int,input().split())
    l,r = k,k#左结点以及右结点：当目前的结点并不是最终结点时，通过循环的方式对结点进行更新操作
    ans = 1
    res = 1#表示当前层结点对应的子结点数量
    #当前结点对应的左子结点：(i - 1) * m + 2 以及右子结点:i * m + 1
    while r * m + 1 <= n:
        res *= m
        l = (l - 1) * m + 2
        r = r * m + 1
        ans += res
    #由于如果右子结点数量大于n时，直接退出循环了，没有对左节点进行更新操作。因此这里还需要更新一次
    l = (l - 1) * m + 2
    cnt = max(0,n - l + 1)
    ans += cnt
    print(ans)
### 3501 硬币兑换
是否需要重刷：要
学会知识点：
这道题目最主要的是一种思维，如何优雅的进行暴力。列举出每一种可能性，而不是去判断答案是否合理了。这里没有办法判断答案是否需要二分性质。就算答案有二分性质，但是check（ans）时也是暴力求解的。那还不要只进行一次暴力求解
同时我觉得硬币数量最多对应的面值不是2023之前的数字。因为这样一个性质：面值越少，数量越少。到后面数值越来越大的时候，数量才开始多了起来。
一般不存在将这两个相同的硬币同时丢进去的情况，因为这样子的话直接减少了两个硬币。
当然我这个说法都是面向答案的说法。
### 纯质数1561
是否需要重刷：要
注意的知识点：
1 读题十进制数位的意思是：指的是个位，十位，百位等等
2 复习了一遍质数的筛法
def get_prime(n):
    vis = [0] * (n + 1)
    prime = []
    vis[0] = vis[1] = 1
    for i in range(2,n + 1):
        if vis[i] == 0:
            prime.append(i)
            for j in range(i + i,n + 1,i):
                vis[j] = 1
    return prime






















