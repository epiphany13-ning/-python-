### 时间复杂度：
O(n):数据大小：10e8
O(nlogn):10e6
O(n**2):10d3
### 杂题：巧用各种方法
利用word，手和笔，excel

求出数的每个位置数目：
a = int(input())
while a!= 0:
    a %= 10
    a //= 10
要刷题目：
1 排列字母
2 纸张尺寸
3 付账问题
4 成绩统计
四舍五入：round函数
用整数100去乘精度较小，100.0去乘更大

四舍六入五留双：
代码实现：
###k倍区间
这道题目自己为什么没有想到这样子的思路：
1看到区间和时没有想到用前缀和去做
2两个数对某个数取余之后发现模相同，那它们相减之后一定是这个数的倍数。
###冰雹数
没有想到的思路：
这道题自己写的时间复杂度是：O(n ** 2)
数据是10e5，如果没有剪枝。这个做法是没有办法通过的。
因此自己应该往剪枝那一个方向去想。
否则就是算法有问题。
剪枝的方向：算过的数不需要再进行计算
### 机器人繁殖
思路：
看是否能够找到规律，直接找规律做
### 三元组中心问题
思路问题：
用max函数和min找到列表中的最值，时间复杂度是O(n)
可以直接用顺序结构来做
而如果是按遍历来做，需要用嵌套结果来做
以下是两个代码的时间复杂度对比：
""":O(n**3)
n = int(input())
a = list(map(int,input().split()))
ans = []
#定好中间的索引，看其左边和右边有没有比它大的
#j : 1,n-2
for j in range(1,n - 1):
    for i in range(0,j):
        for k in range(j + 1,n):#这里是嵌套关系
            if a[i] < a[j] and a[j] < a[k]:
                ans.append(j)
ans1 = set(ans)
print(len(ans1))
""":0(n**2)
n = int(input())
a = list(map(int,input().split()))
ans = 0
#定好中间的索引，看其左边和右边有没有比它大的
#j : 1,n-2
for j in range(1,n - 1):
    i = min(a[0:j])#这里是顺序关系
    k = max(a[j+1:n+ 1])
    if i < a[j] and a[j] < k:
        ans += 1
print(ans)

一定记得要保存数据，github
递推和递归：
题目：
数字三角形，
斐波那契数列
42点问题：
天干地支
数的计算
递推的推广：
用数组来存储答案，不需要每次对答案进行判断
递推的推广：
用数组来存储答案，索引和答案来对应
递推：根据相邻元素的关系，来推算出目前元素的数值。求出一个式子来，递推是通过前面的元素来推出目前值
递归：不断调用自己，直到递归出口
递推好想，而递归不好















